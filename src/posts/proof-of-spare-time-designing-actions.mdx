---
title: "Proof of Spare Time: Designing Actions"
date: 2020-08-02 10:58:02
status: draft
---

- [Introductory Post](proof-of-spare-time)

In the last post I introduced a consistency rule as a desirable property for distributed reducers.

> Given a tree of actions $T$ and a partial order "$\leq_T$" implied by that tree, any reduction order $R$ in which $a \leq_T b \implies a <_R b$ will result in the same state.

To see how we can build actions to satisfy this rule, lets look at a simplified state for the coffee table voting section.

```typescript
type SignedTopic = {
  topic: Topic
  proposer: Signature<Topic>
  votes: {
    [personId in string]?: Vote
  }
}
type State = {
  [id in string]?: Topic
}

// these are less important to the consistency rule, but for clarity are provided
type Topic = {
  title: string
  description: string
  id: string
  date: Date
}
type Signature<T> = ArrayBuffer & {_type: 'signature' _signed: T}

type Person = {
  id: string
  sign: <T>(t: T) => Signature<T>
  validate<T>(s: Signature<T>) => boolean
}

type Vote = Signature<[Topic, Date]>
```

To add a new topic, we just add a new key to the state that maps to that topic. What order we do that in doesn't matter. we'll always end up in the same state once we've applied all the actions.

The structure of the votes may seem strange. We remember the full structure of every vote within the state, rather than just remembering the count. This is to allow us to fulfill our consistency rule for the `upvote` and `downvote` actions. If we only remembered the count, it would be hard to know when a user was allowed to vote on a topic. Remembering the whole vote allows us to fully handle new voting actions. 

When a new vote comes in, and there is already a vote in that slot, we can decide which one to pick based on the date embedded in the vote type. Dates are usually not a safe thing to rely on in a distributed system, but in this case we know that all dates must have been generated by the same user, because they are signed. We can also make sure that no one else can vote for that user by validating the signature.

This structure of state would implement a version of voting called [approval voting](https://en.wikipedia.org/wiki/Approval_voting). Approval voting is most common on social media sites. likes on facebook and hearts on twitter are both approval votes, because we can only vote +1 and we can vote for as many items as we want. This is unusual for lean coffee. The more common structure is to give each participant $n$ votes to distribute among the topics however they see fit. Lean coffee calls this *dot voting*.

Now that we have the simplest structure of voting defined, it's not hard to see how we would extend this state to handle dot votes. We can simply change our vote type as follows;

```typescript
type Vote = Signature<[Topic, Date, number]>
```

The intuition here is that each of the participants $n$ votes gets a number between 1 and $n$. When they cast a new vote, the reducer checks if that number has already been cast in the state. If not, all is well. If it has already been cast (or if an additional cast action gets added later) then we can make up some rule for determining what happens in a consistent way. We have a few options of how this could work.

* Votes are cast without a number associated with them. Numbers are assigned according to timestamps, and roll over when we run out of votes.
* Votes are cast with a number associated with them. The most recent vote for a given number wins.
* Votes are cast with a number associated with them. There is an additional action to explicitly "uncast" a vote.

The user experience of each of these is going to depend on how good our network turns out to be. I prefer the final version, because it is the least likely to have "surprising" intermediate states. All of them will never show more votes cast than is possible. They will also never show a vote cast for something that the participant did not vote for. However, thinking about all of the votes together as a set, each of these could temporarily show remote users a state that never occurred for the participant casting the votes. Our consistency rule only guarantees that once all actions have been distributed, everyone will be in the same state.
